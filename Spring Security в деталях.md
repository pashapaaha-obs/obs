https://www.youtube.com/playlist?list=PLs_aLxm3VDLu9ghcQhTHOT84zmqLgAwdL

3 этапа предоставления доступа
1. идентификация
2. аутентификация
3. авторизация
	1. через роли
	2. через правила


realm -- источник пользователей

При поступлении запроса от пользователя, перед тем, как направить запрос в сервлет spring security проводит его через цепочку фильтров и, в зависимости от результата, может направить этот запрос на сервлет, либо вернуть пользователю код ошибки аутентификации/авторизации

При получении ответа от сервлета, ответ проходит ту же цепочку фильтров в обратном порядке (?)

При необходимости аутентификации spring security по-умолчанию переводит пользователя на форму ввода логина и пароля (форма из коробки)
В процессе создаёт сессионный cookie, в котором хранятся данные авторизации 

Запрос аутентификации -- экземпляр класса, реализующего интерфейс Authentication 

Filter в SpringSecurity формирует запрос аутентификации и передаёт его в AuthenticationManager, который в случае неуспеха возвращает ошибку с деталями (нет доступа, неправильные креды, пользователь заблокирован)

SecurityFilterChain 

AuthenticationManager обращается к AuthenticationProvider, который находит пользователя в своём источнике данных(UserDetailService) и проверяет его. Провайдеров может быть несколько в цепочке

В реализации провайдера по-умолчанию (DaoAuthenticationProvider) пользователь ищется в базе данных по его username

После этих действий фильтр сохраняет результат (Authentication) в контексте безопасности 

Запрос аутентификации и результат, это не один и тот же объект, хотя оба реализуют один интерфейс


SecurityContextHolder (static) хранит информацию о текущей сессии безопасности, авторизованного юзера


По умолчанию spring-security создаёт одного пользователя с именем user, и паролем, который выводится в логах при старте приложения